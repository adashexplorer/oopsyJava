# oopsyJava

> A hands-on journey through Java‚Äôs Object-Oriented Universe üöÄ

---

## üìö What you'll learn
- Fundamentals of Object-Oriented programming in Java
- Real-world example of each OOP principle
- Design Patterns & best practices
- Code structure, encapsulation & modularity

---

## üß± Core Concepts Covered
- ‚úÖ Core principles of OOP
     - Encapsulation
         - Definition & benefits
         - Access modifiers `private`, `public`, `protected`, `default`
         - Getters & Setters (POJO / Beans)
         - Immutability & final classes
     - Abstraction
         - Abstract classes vs Interfaces
         - Hiding implementation details
         - `abstract` keyword
         - Use cases & real world examples
     - Inheritance
         - `extends` keyword
         - Single vs Multi-level inheritance
         - Constructor chaining (`super` keyword)
         - `final` keyword on classes, methods & variables
         - `is-a` vs `has-a` relationship
     - Polymorphism
         - Compile-time (Method overloading)
         - Run-time (Method overriding)
         - Covariant return types
         - Dynamic dispatch
         - `@Override` annotation
- ‚úÖ Classes & Objects
     - Declaring classes & creating objects
     - Class members - fields, constructors & methods
     - constructor overloading
     - static vs non-static context
     - Nested, inner, anonymous and static nested classes
     - `this` keyword & it's uses
- ‚úÖ Interfaces & Abstract Classes
     - Multiple inheritance using interfaces
     - Functional interfaces (Java 8+)
     - Default & static methods in interfaces
     - Difference between Abstract classes & Interfaces
     - Marker interfaces
- ‚úÖ Java Access Modifiers
     - `public`, `private`, `protected`, package-private
     - Best practices for Access Control
     - Use in Class, Method & Constructor design
- ‚úÖ Object class methods
     - `toString()`, `equals()`, `hashCode()`, `clone()`, `finalize()`, `getClass()`,` wait()`/`notify()`/`notifyAll()`
     - Overriding `hashcode()` & `equals()` method
     - `==` vs `equals()`
- ‚úÖ Method overloading & Method overriding
     - Rules for overloading (Compile time)
     - Rules for overriding (Run time)
     - Covariant return types
     - Access Modifier and exception rules during overriding
- ‚úÖ Constructors
     - Default & parameterized constructor
     - Constructor chaining with `this()` and `super()` keyword
     - static blocks vs constructors
     - Object life cycle & memory allocation
- ‚úÖ Static vs Non-static 
     - static variables / methods / blocks
     - static initialization blocks
     - static nested class
     - Best practices and common mistakes
- ‚úÖ `final`, `this` & `super` keyword
     - `final` keyword in variable, method and class
     - `this` keyword to refer current object
     - `super` keyword to access parent class members
- ‚úÖ Encapsulation & Data Hiding
     - private fields + public getters / setters
     - Immutable classes
     - Java Beans conventions
- ‚úÖ Object life cycle & garbage collection
     - Object creation & destruction 
     - Eligibility for GC
     - `finalize()` method (deprecated)
     - WeakReferences & PhantomReferences 
- ‚úÖ Design Principles (SOLID & GRASP)
     - SOLID
        - S : Single Responsibility
        - O : Open/Closed Principle
        - L : Liskov Substitution
        - I : Interface Segregation
        - D : Dependency Inversion
     - GRASP
        - Creator, Controller, Low Coupling, High Cohesion etc.
- ‚úÖ UML class diagrams
     - Class diagrams
     - Relationship types (association, aggregation, composition)
     - Multiplicity, Inheritance arrows
     - Modeling OOP structures
- ‚úÖ Common OOP design patterns
     - Factory
     - Singleton
     - Strategy
     - Observer
     - Builder
     - Decorator
     - Adapter
     - Template Method
- ‚úÖ OOP in Java 8+
     - Functional Interfaces & Lambda expressions
     - Streams with OOP models
     - Default method in Interfaces
     - Records (Java 14+)
     - Sealed classes (Java 15+)
- ‚úÖ Composition & Inheritance
     - Pros vs Cons
     - Real example : Strategy Pattern, Delegation
     - Avoiding tight coupling
- ‚úÖ Object cloning & copying
     - Deep copy vs Shallow copy
     - `clone()` method
     - Copy constructors
     - Serialization-based copying
     - Manual deep copy
- ‚úÖ Enums & Singleton OOP usage
     - Enum types & methods
     - Enum as singleton
     - Enum-based design patterns
- ‚úÖ Object Identity vs Object Equality
     - Difference between `==`, `equals()` `hashcode()`
     - Identity : same memory reference 
     - Equality : same logical content
     - contract between `equals()` and `hashcode()`
- ‚úÖ Object relationships in OOP
     - Association
     - Aggregation
     - Composition
     - Dependency
     - Inheritance (already covered above, but this add nuance)
     - use-cases examples & class diagrams for each
- ‚úÖ Immutability in OOP
     - Why immutability matters ?
     - How to design immutable class ?
     - use of `final` + defensive copying
     - `record` types in Java 14+ for immutability
- ‚úÖ Refactoring technique in OOP
     - Extract class & Extract methods
     - Replace Inheritance with Delegation
     - Encapsulate field
     - Push down / Pull up methods and fields
- ‚úÖ OOPs with multithreading
     - Race condition on shared objects
     - Synchronized methods & blocks
     - `volatile` keyword & memory visibility
     - Thread safe OOP design (immutable objects, thread confinement)
- ‚úÖ Object serialization
     - `Serializable` interface
     - How serialization breaks encapsulation
     - How to secure serialization ?
     - `Externalizable` vs `Serializable`
- ‚úÖ Lazy initialization & Singleton patterns
     - Best practices for lazy instantiation
     - Lazy loading in real world OOP systems
     - Thread-safe singleton designs (enum, `Holder`, `Double-Checked locking`)
- ‚úÖ Designing for testability
     - OOP designs that are test friendly
     - Loose coupling via interfaces
     - Dependency Injection (DI) basics
     - Mocking objects using Interfaces
- ‚úÖ OOP Pitfalls & Anti-patterns
     - God object
     - Spaghetti code via overuse of inheritance
     - Refused Bequest
     - Circle-ellipse problem
     - Anemic Domain model
- ‚úÖ Principles of a good OOP API design
     - Fluent interface design
     - Information hiding
     - Consistent object construction patterns (Builder, Factory)
     - Method chaining and return `this`
- ‚úÖ Sealed classes & Records (Java 14+)
     - Sealed classes for controlled inheritance
     - `record` for lightweight data carriers 
     - When and where to use sealed hierarchies
- ‚úÖ Best practices in OOP
     - Favor composition
     - Avoid overuse of Inheritance
     - `DRY` and `KISS` principles
     - Law of Demeter (`LoD`)
- ‚úÖ Real world OOP use cases in Java
     - Banking System
     - Library Management
     - Inventory Tracking
     - E-commerce cart model
     - Event-driven models (Pub-sub pattern)

---

## üóÇÔ∏è Folder Structure

---
## üß† How to Use
1. Clone this repo.
``` 
   bash
   git clone https://github.com/yourusername/oopsyJava.git
```


